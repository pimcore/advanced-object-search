<?php
/**
 * Pimcore
 *
 * This source file is available under two different licenses:
 * - GNU General Public License version 3 (GPLv3)
 * - Pimcore Enterprise License (PEL)
 * Full copyright and license information is available in
 * LICENSE.md which is distributed with this source code.
 *
 * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)
 * @license    http://www.pimcore.org/license     GPLv3 and PEL
 */


namespace AdvancedObjectSearchBundle\Filter\FieldDefinitionAdapter;

use AdvancedObjectSearchBundle\Filter\FieldSelectionInformation;
use AdvancedObjectSearchBundle\Filter\FilterEntry;
use ONGR\ElasticsearchDSL\BuilderInterface;
use ONGR\ElasticsearchDSL\Query\Compound\BoolQuery;
use ONGR\ElasticsearchDSL\Query\Joining\NestedQuery;
use Pimcore\Model\DataObject\ClassDefinition\Data;
use Pimcore\Model\DataObject\Concrete;
use Pimcore\Model\DataObject\Objectbrick\Definition;

class Objectbricks extends DefaultAdapter implements FieldDefinitionAdapterInterface {

    /**
     * field type for search frontend
     *
     * @var string
     */
    protected $fieldType = "objectbricks";

    /**
     * @var Data\Objectbricks
     */
    protected $fieldDefinition;

    /**
     * @return array
     */
    public function getESMapping() {

        $allowedTypes = $this->fieldDefinition->getAllowedTypes();

        $mappingProperties = [];

        foreach($allowedTypes as $objectBrickDefinitionKey) {
            $objectBrickDefinition = Definition::getByKey($objectBrickDefinitionKey);

            $childMappingProperties = [];
            foreach($objectBrickDefinition->getFieldDefinitions() as $field) {
                $fieldDefinitionAdapter = $this->service->getFieldDefinitionAdapter($field, $this->considerInheritance);
                list($key, $mappingEntry) = $fieldDefinitionAdapter->getESMapping();
                $childMappingProperties[$key] = $mappingEntry;
            }

            $mappingProperties[$objectBrickDefinitionKey] = [
                'type' => 'nested',
                'properties' => $childMappingProperties
            ];

        }

        return [
            $this->fieldDefinition->getName(),
            [
                'type' => 'nested',
                'properties' => $mappingProperties
            ]
        ];
    }


    /**
     * @param $fieldFilter
     *
     * filter field format as follows:
     *      [
     *          'type' => 'OBJECT_BRICK_TYPE'
     *          'filterCondition' => FilterEntry[]  - FULL FEATURES FILTER ENTRY ARRAY
     *      ]
     *
     * @param bool $ignoreInheritance
     * @param string $path
     * @return BuilderInterface
     */
    public function getQueryPart($fieldFilter, $ignoreInheritance = false, $path = "")
    {
        $filterEntryObject = $this->service->buildFilterEntryObject($fieldFilter['filterCondition']);
        $objectBrickType = $fieldFilter['type'];

        $innerBoolQuery = new BoolQuery();

        $innerPath = $path . $this->fieldDefinition->getName() . "." . $objectBrickType;


        if($filterEntryObject->getFilterEntryData() instanceof BuilderInterface) {

            // add given builder interface without any further processing
            $innerBoolQuery->add($filterEntryObject->getFilterEntryData(), $filterEntryObject->getOuterOperator());

        } else {

            $definition = Definition::getByKey($objectBrickType);
            $fieldDefinition = $definition->getFielddefinition($filterEntryObject->getFieldname());
            $fieldDefinitionAdapter = $this->service->getFieldDefinitionAdapter($fieldDefinition, $this->considerInheritance);

            if($filterEntryObject->getOperator() == FilterEntry::EXISTS || $filterEntryObject->getOperator() == FilterEntry::NOT_EXISTS) {

                //add exists filter generated by filter definition adapter
                $innerBoolQuery->add(
                    $fieldDefinitionAdapter->getExistsFilter($filterEntryObject->getFilterEntryData(), $filterEntryObject->getIgnoreInheritance(), $innerPath . "."),
                    $filterEntryObject->getOuterOperator()
                );

            } else {

                //add query part generated by filter definition adapter
                $innerBoolQuery->add(
                    $fieldDefinitionAdapter->getQueryPart($filterEntryObject->getFilterEntryData(), $filterEntryObject->getIgnoreInheritance(), $innerPath . "."),
                    $filterEntryObject->getOuterOperator()
                );

            }


        }

        return new NestedQuery(
            $path . $this->fieldDefinition->getName(),
            new NestedQuery($innerPath, $innerBoolQuery)
        );

    }

    /**
     * @param Concrete $object
     * @return array
     */
    public function getIndexData($object) {

        $data = [];

        $getter = "get" . ucfirst($this->fieldDefinition->getName());
        $objectBrickContainer = $object->$getter();

        if($objectBrickContainer) {


            foreach($objectBrickContainer->getItems() as $item) {
                $definition = Definition::getByKey($item->getType());

                $brickData = [];

                foreach($definition->getFieldDefinitions() as $key => $field) {
                    $fieldDefinitionAdapter = $this->service->getFieldDefinitionAdapter($field, $this->considerInheritance);
                    $brickData[$key] = $fieldDefinitionAdapter->getIndexData($item);
                }

                $data[$item->getType()][] = $brickData;

            }

        }

        return $data;
    }

    /**
     * @inheritdoc
     */
    public function getFieldSelectionInformation()
    {

        $allowedTypes = [];
        foreach($this->fieldDefinition->getAllowedTypes() as $allowedType) {
            $allowedTypes[] = [$allowedType];
        }

        return [new FieldSelectionInformation(
            $this->fieldDefinition->getName(),
            $this->fieldDefinition->getTitle(),
            $this->fieldType,
            [
                'allowedTypes' => $allowedTypes,
            ]
        )];

    }

}
